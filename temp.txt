# Decision Tree Refactoring Plan

## Backend Steps

1. **Analyze Current Decision-Tree.json Structure**
   - Review the current structure to identify all components
   - Map out dependencies between different sections
   - Identify which parts are most critical for the initial report generation

2. **Create Modular Decision Tree Structure**
   - Split the monolithic Decision-Tree.json into separate files:
     - `building-classifications.json` - Building class definitions and requirements
     - `climate-zones.json` - Climate zone specifications and requirements
     - `compliance-pathways.json` - Different compliance pathways and their criteria
     - `special-requirements.json` - Special requirements and triggers
     - `exemptions.json` - Exemption rules and conditions

3. **Create Section-Specific Decision Trees**
   - Develop separate decision trees for each NCC section:
     - `section-j-energy-efficiency.json` - Energy efficiency requirements
     - `section-j-lighting.json` - Lighting requirements
     - `section-j-meters.json` - Metering requirements
     - (Future sections can be added as needed)

4. **Update Utility Functions**
   - Modify `decisionTreeUtils.js` to:
     - Load the appropriate decision tree based on the section being processed
     - Provide section-specific utility functions
     - Implement a factory pattern to create the appropriate decision tree handler

5. **Update Report Service**
   - Refactor `reportService.js` to:
     - Accept a section parameter to determine which decision tree to use
     - Generate section-specific reports
     - Combine multiple section reports into a comprehensive report when needed

6. **Create API Endpoints for Section-Specific Reports**
   - Add new endpoints in `projectRoutes.js`:
     - `/api/projects/:id/report/energy` - Energy efficiency report
     - `/api/projects/:id/report/lighting` - Lighting report
     - `/api/projects/:id/report/meters` - Metering report
     - `/api/projects/:id/report/full` - Comprehensive report (all sections)

7. **Update Project Controller**
   - Modify `projectController.js` to:
     - Handle section-specific report generation
     - Validate section parameters
     - Return appropriate error messages for invalid sections

## Frontend Steps

1. **Update Project Details Page**
   - Add section selection UI to the project details page:
     - Radio buttons or dropdown to select report sections
     - "Generate Full Report" option for comprehensive reports
     - Individual section report buttons

2. **Create Section-Specific Report Components**
   - Develop separate React components for each section report:
     - `EnergyEfficiencyReport.js`
     - `LightingReport.js`
     - `MetersReport.js`
     - `FullReport.js` (combines all section reports)

3. **Update Redux Store**
   - Modify `projectSlice.js` to:
     - Add actions for section-specific report generation
     - Store section-specific reports in the Redux state
     - Handle loading states for different report types

4. **Update API Service**
   - Modify the API service to:
     - Add methods for fetching section-specific reports
     - Handle errors for invalid section requests
     - Provide appropriate feedback to the user

5. **Enhance Report Display**
   - Update the report display component to:
     - Show section-specific information
     - Provide navigation between different report sections
     - Allow printing or exporting individual section reports

6. **Add Report Comparison Feature**
   - Implement a feature to compare different section reports:
     - Side-by-side comparison view
     - Highlight differences between sections
     - Provide recommendations based on comparisons

## Implementation Strategy

1. **Phase 1: Backend Refactoring**
   - Split the decision tree into modular files
   - Update utility functions to work with the new structure
   - Implement section-specific report generation

2. **Phase 2: API Updates**
   - Create new endpoints for section-specific reports
   - Update controllers to handle section parameters
   - Test API endpoints with Postman or similar tools

3. **Phase 3: Frontend Updates**
   - Update UI to allow section selection
   - Create section-specific report components
   - Implement report comparison feature

4. **Phase 4: Testing and Refinement**
   - Test the entire flow from UI to backend
   - Refine the decision trees based on testing results
   - Optimize performance for large decision trees

## Benefits of This Approach

1. **Modularity**: Each decision tree can be maintained independently
2. **Scalability**: New sections can be added without modifying existing code
3. **Performance**: Smaller, focused decision trees load faster
4. **Maintainability**: Easier to update specific sections without affecting others
5. **User Experience**: Users can focus on specific aspects of compliance 

Decision-Tree.json
├── version
├── last_updated
└── decision_tree
    ├── building_classification
    ├── building_fabric
    ├── special_requirements
    ├── compliance_pathways
└── exemptions 

building_fabric
├── walls
│   └── external
│       ├── r_value_by_zone
│       │   ├── Zones_1_3
│       │   ├── Zones_4_6
│       │   └── Zones_7_8
│       └── thermal_breaks
└── roof
    ├── r_value_by_zone
    │   ├── Zones_1_5
    │   ├── Zone_6
    │   └── Zones_7_8
    └── solar_absorptance
        ├── max
        └── exempt_zones 

special_requirements
├── renewable_energy
│   ├── trigger
│   └── requirements
│       ├── roof_allocation
│       └── electrical
└── ev_charging
    ├── trigger
    └── requirements 

compliance_pathways
├── DTS (Deemed-to-Satisfy)
│   ├── description
│   ├── applicability
│   └── verification
└── JV3 (Performance Solution)
    ├── description
    ├── applicability
    └── verification 

exemptions
├── minor_use_rule
│   ├── threshold
│   └── excluded_classes
└── heritage_buildings
    ├── conditions
    └── limitations 

# Extreme Simplification Strategy for Decision Tree Refactoring

## Minimal Change Approach

Instead of a complete overhaul, I recommend a step-by-step approach with minimal changes between each test. Here's how we can break this down:

# Step-by-Step Modular Decision Tree Implementation

## Phase 1: Initial Setup and First Section

### Step 1: Create Basic Directory Structure
1. Create a new directory `decision-trees/` in the backend folder
2. Create a simple configuration file `decision-tree-config.js` that will control which sections are loaded
3. Create a basic factory function in a new file `decisionTreeFactory.js` that will load the decision tree sections
4. Test: Run the backend to ensure it starts without errors
Done 

### Step 2: Extract Exemptions Section
1. Create `decision-trees/exemptions.json` with the exemptions data from the original Decision-Tree.json
2. Update the factory to load this file
3. Create a simple adapter function to convert the new format to the format expected by existing code
4. Test: Add a simple endpoint `/api/test/exemptions` that returns the exemptions data
Done 

### Step 3: Update Exemptions Utility Function
1. Modify `getExemptions()` in `decisionTreeUtils.js` to use the new structure
2. Test: Call the `/api/test/exemptions` endpoint and verify it returns the correct data
Done


### Step 4: Extract Compliance Pathways
1. Create `decision-trees/compliance-pathways.json` with the compliance pathways data
2. Update the factory to load this file
3. Create an adapter for compliance pathways
4. Test: Add an endpoint `/api/test/compliance-pathways` and verify it works



### Step 5: Update Compliance Pathways Utility
1. Modify `getCompliancePathway()` in `decisionTreeUtils.js` to use the new structure
2. Test: Call the `/api/test/compliance-pathways` endpoint and verify it returns the correct data

### Step 6: Extract Special Requirements
1. Create `decision-trees/special-requirements.json` with the special requirements data
2. Update the factory to load this file
3. Create an adapter for special requirements
4. Test: Add an endpoint `/api/test/special-requirements` and verify it works

### Step 7: Update Special Requirements Utility
1. Modify `getSpecialRequirements()` in `decisionTreeUtils.js` to use the new structure
2. Test: Call the `/api/test/special-requirements` endpoint and verify it returns the correct data

## Phase 3: Add Building Classification and Climate Zones

### Step 8: Extract Building Classifications
1. Create `decision-trees/building-classifications.json` with the building classification data
2. Update the factory to load this file
3. Create an adapter for building classifications
4. Test: Add an endpoint `/api/test/building-classifications` and verify it works

### Step 9: Update Building Classification Utility
1. Modify `getBuildingClassification()` in `decisionTreeUtils.js` to use the new structure
2. Test: Call the `/api/test/building-classifications` endpoint and verify it returns the correct data

### Step 10: Extract Climate Zones
1. Create `decision-trees/climate-zones.json` with the climate zone data
2. Update the factory to load this file
3. Create an adapter for climate zones
4. Test: Add an endpoint `/api/test/climate-zones` and verify it works

### Step 11: Update Climate Zone Utility
1. Modify `getClimateZoneByLocation()` in `decisionTreeUtils.js` to use the new structure
2. Test: Call the `/api/test/climate-zones` endpoint and verify it returns the correct data

## Phase 4: Add Building Fabric

### Step 12: Extract Building Fabric
1. Create `decision-trees/building-fabric.json` with the building fabric data
2. Update the factory to load this file
3. Create an adapter for building fabric
4. Test: Add an endpoint `/api/test/building-fabric` and verify it works

### Step 13: Update Building Fabric Utility
1. Modify any building fabric related functions in `decisionTreeUtils.js` to use the new structure
2. Test: Call the `/api/test/building-fabric` endpoint and verify it returns the correct data

## Phase 5: Create Section-Specific Reports

### Step 14: Create Exemptions Report
1. Create a new function in `reportService.js` to generate an exemptions report
2. Add an endpoint `/api/projects/:id/report/exemptions` that uses this function
3. Test: Generate an exemptions report for a project and verify it's correct

### Step 15: Create Compliance Pathways Report
1. Create a new function in `reportService.js` to generate a compliance pathways report
2. Add an endpoint `/api/projects/:id/report/compliance-pathways` that uses this function
3. Test: Generate a compliance pathways report for a project and verify it's correct

### Step 16: Create Special Requirements Report
1. Create a new function in `reportService.js` to generate a special requirements report
2. Add an endpoint `/api/projects/:id/report/special-requirements` that uses this function
3. Test: Generate a special requirements report for a project and verify it's correct

## Phase 6: Update Frontend

### Step 17: Add Section Selection to Project Details
1. Update the project details page to include a section selection dropdown
2. Add buttons for generating section-specific reports
3. Test: Navigate to a project details page and verify the UI changes

### Step 18: Create Section Report Components
1. Create a new component for displaying section-specific reports
2. Update the project report page to use this component
3. Test: Generate a section-specific report and verify it displays correctly

### Step 19: Update Redux Store
1. Add actions and reducers for section-specific reports
2. Update the API service to fetch section-specific reports
3. Test: Generate reports from the UI and verify they're stored in Redux

### Step 20: Create Full Report Component
1. Create a component that combines all section reports
2. Add a "Generate Full Report" button to the project details page
3. Test: Generate a full report and verify it includes all sections

## Phase 7: Final Integration

### Step 21: Remove Old Decision Tree
1. Update the factory to no longer support the old structure
2. Remove the old Decision-Tree.json file
3. Test: Verify all functionality continues to work without the old file

### Step 22: Clean Up and Optimize
1. Remove any temporary test endpoints
2. Optimize the factory and adapters
3. Test: Verify all functionality continues to work after cleanup

### Step 23: Documentation
1. Update documentation to reflect the new modular structure
2. Add examples of how to add new sections
3. Test: Follow the documentation to add a new section and verify it works

