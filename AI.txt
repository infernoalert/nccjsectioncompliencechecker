# NCC Section Compliance Checker Project

## Project Overview
This project is a web application for checking compliance with the National Construction Code (NCC) for building projects. It allows users to create projects, specify building types, locations, and other details, and then generate compliance reports based on the NCC requirements.

## Architecture
- **Frontend**: React with Redux for state management
- **Backend**: Node.js with Express
- **Database**: MongoDB with Mongoose ODM
- **Process Manager**: PM2 for production deployment

## Key Components

### Backend
- **Models**:
  - Project: Stores project information including building type, location, climate zone, etc.
  - User: Stores user information for authentication
  - ClimateZone: Stores climate zone information
  - BuildingFabric: Stores building fabric specifications
  - SpecialRequirement: Stores special requirements for buildings
  - CompliancePathway: Stores compliance pathway information

- **Controllers**:
  - projectController.js: Handles project CRUD operations
  - userController.js: Handles user authentication and management
  - buildingClassController.js: Handles building classification operations

- **Services**:
  - reportService.js: Generates compliance reports
  - complianceService.js: Checks compliance with NCC requirements

- **Utils**:
  - **sectionLoader.js (New)**: Utility to load and cache all standardized report section JSON files from a designated directory (e.g., `data/decision-trees/` or `data/report-sections/`). Performs basic validation on file structure.
  - decisionTreeUtils.js: Provides functions primarily for accessing core data not suitable for the dynamic JSON format (e.g., `getBuildingClassification`, `getClimateZoneByLocation`). Less emphasis on individual getters for simple JSON data sections.
  - locationUtils.js: Provides functions to access location and detailed climate zone data.
  - validation.js: Provides validation functions for project data.

- **Data Files**:
  - Decision-Tree.json: Contains the decision tree structure for building classifications, climate zones, and compliance pathways
  - locationToClimateZone.json: Maps locations to climate zones and contains heating, cooling, and dehumidification data
  - buildingTypeToClassification.json: Maps building types to NCC classifications
  - J1P2 Calculation Files:
    - j1p2totalheatingload.js: Calculates the total heating load based on Annual Heating Degree Hours and Total Area of Habitable Rooms
    - j1p2totalcoolingload.js: Calculates the total cooling load based on Annual Cooling Degree Hours, Annual Dehumidification Gram Hours, and Total Area of Habitable Rooms
    - j1p2thermalenergyload.js: Calculates the thermal energy load based on the heating and cooling load limits

### Frontend
- **Components**:
  - NewProject.js: Form for creating new projects
  - ProjectList.js: Displays a list of user's projects
  - ProjectDetails.js: Displays details of a specific project
  - **ProjectReport.js**: Displays the compliance report. Renders core sections (Project Info, Classification, Zone, J1P2 Calcs) directly from the report object and **dynamically renders sections from the `report.dynamicSections` array using the `DynamicSectionRenderer` component.**
  - **DynamicSectionRenderer.js (New)**: Helper component responsible for rendering individual dynamic sections and their content blocks based on the `contentType` specified in the data.
  - *Other UI components.*

- **Redux**:
  - projectSlice.js: Manages project-related state
  - authSlice.js: Manages authentication state

## Environment Configuration

### Backend Environment
The backend uses environment-specific configuration files:
- `.env.development`: Development environment configuration
- `.env.production`: Production environment configuration

To run the backend, copy the appropriate environment file to `.env` in the backend directory.

### Frontend Environment
The frontend also uses environment-specific configuration files:
- `.env.development`: Development environment configuration
- `.env.production`: Production environment configuration

To run the frontend, copy the appropriate environment file to `.env` in the frontend directory.

## Available Scripts

### Backend
- `npm run dev`: Starts the development server with nodemon
- `npm start` or `npm run start:prod`: Starts the production server
- `npm run start:dev`: Starts the development server (same as `npm run dev`)
- `npm test`: Runs the test suite
- `npm run pm2:start`: Starts the application with PM2 in production mode
- `npm run pm2:stop`: Stops the PM2 application
- `npm run pm2:restart`: Restarts the PM2 application
- `npm run pm2:delete`: Deletes the PM2 application
- `npm run pm2:logs`: Shows the PM2 logs
- `npm run pm2:monit`: Opens the PM2 Monitor interface
- `npm run pm2:status`: Shows the PM2 status

### Frontend
- `npm start` or `npm run start:dev`: Starts the development server
- `npm run start:prod`: Starts the production server
- `npm run build`: Builds the app for production
- `npm run build:dev`: Builds the app for development
- `npm test`: Runs the test suite
- `npm run eject`: Ejects from Create React App

## Production Deployment

### Backend Deployment with PM2

PM2 is a process manager for Node.js applications that helps keep your application running 24/7 and provides features like automatic restarts, load balancing, and Monitor.

#### PM2 Configuration

The PM2 configuration is defined in the `ecosystem.config.js` file in the backend directory. This file contains the following settings:

- **name**: The name of the application in PM2
- **script**: The entry point script (server.js)
- **instances**: Number of instances to launch (set to 'max' to use all available CPU cores)
- **exec_mode**: Execution mode ('cluster' for load balancing)
- **autorestart**: Automatically restart the application if it crashes
- **watch**: Watch for file changes and restart the application
- **max_memory_restart**: Restart the application if memory exceeds the specified limit
- **env_production**: Environment variables for production mode
- **env**: Environment variables for development mode
- **env_file**: Path to the environment file
- **log_date_format**: Format for log timestamps
- **error_file**: Path to the error log file
- **out_file**: Path to the output log file
- **merge_logs**: Merge logs from all instances
- **time**: Add timestamps to logs

#### Deployment Scripts

The backend includes deployment scripts for both Windows and Unix-based systems:

- **deploy.bat**: Windows batch file for deployment
- **deploy.sh**: Shell script for Unix-based systems

These scripts perform the following tasks:
1. Stop any running instances of the application
2. Install dependencies
3. Copy the production environment file to .env
4. Start the application with PM2
5. Save the PM2 process list
6. Display the current PM2 status

#### PM2 Commands

The following PM2 commands are available through npm scripts:

- **npm run pm2:start**: Start the application with PM2
- **npm run pm2:stop**: Stop the application
- **npm run pm2:restart**: Restart the application
- **npm run pm2:delete**: Delete the application from PM2
- **npm run pm2:logs**: View the application logs
- **npm run pm2:monit**: Open the PM2 Monitor interface
- **npm run pm2:status**: View the PM2 status

### Frontend Deployment

The frontend can be deployed by building the application and serving the static files:

1. Build the application:
   ```bash
   npm run build
   ```

2. Deploy the `build` directory to your web server.

## Recent Changes

### J1P2 Calculations for Class_2 and Class_4 Buildings
- Added J1P2 calculations to the Performance Requirement section of the report
- Created three JavaScript files in the `backend/data/decision-trees` directory:
  - `j1p2totalheatingload.js`: Implements the heating load calculation formula
  - `j1p2totalcoolingload.js`: Implements the cooling load calculation formula
  - `j1p2thermalenergyload.js`: Implements the thermal energy load calculation formula
- Updated the `generateJ1P2CalcInfo` method in `reportService.js` to use these files
- The calculations are only displayed for Class_2 and Class_4 buildings

### Climate Data for Class_2 and Class_4 Buildings
- Added heating, cooling, and dehumidification data to the Building Classification & Climate Zone section of the report
- This data is only displayed for Class_2 and Class_4 buildings
- The data is sourced from the `locationToClimateZone.json` file
- Updated the `generateClimateZoneInfo` method in `reportService.js` to include this data
- Updated the `ProjectReport.js` component to conditionally display this data

### Report Structure Reorganization
- Reorganized the report display into four main sections:
  1. General
     - Project Information
     - Building Classification & Climate Zone
     - Compliance Pathway
  2. Performance Requirement
     - Energy Use Requirements
     - J1P2 Calculations (for Class_2 and Class_4 buildings)
  3. DTS - Deemed-to-Satisfy
     - Building Fabric Specifications
     - Special Requirements & Exemptions
     - Elemental Provisions J3
  4. Other 2
     - Exemptions
     - Compliance Results
     - Documentation
- Improved visual organization with clear section headers and dividers
- Maintained all existing functionality while improving the layout

### Project Schema Simplification
- Removed the `buildingClassification` field from the Project schema
- Made `buildingFabric`, `specialRequirements`, and `compliancePathway` fields optional
- Updated the `buildingType` field to be a simple string without an enum
- Added proper validation for `buildingType` using the `buildingTypeToClassification.json` file

### Decision Tree Implementation
- Created utility functions in `decisionTreeUtils.js` to access data from `Decision-Tree.json`
- Implemented functions for building classifications, climate zone requirements, compliance pathways, special requirements, and exemptions
- Updated the `ReportService` class to utilize the new utility functions

### Verification Methods Implementation
The verification methods are implemented as a modular decision tree structure in `verification-methods.json`. This structure works as follows:

1. **Class-Based Organization**:
   - Each building class (Class_2 through Class_9c) has its own set of verification methods
   - Classes are organized hierarchically in the JSON structure
   - A default verification method is provided for cases where a specific class isn't found

2. **Method Structure**:
   Each verification method contains:
   - `condition`: The specific condition or requirement that must be met
   - `description`: A detailed list of requirements that must be satisfied

3. **Class-Specific Examples**:
   - **Class_2**: Includes methods like "J1V1-minimum 4-star NABERS Energy for Apartment Buildings" and "J1V2-Green Star alternative compliance"
   - **Class_3**: Includes methods like "J1V1-minimum 4-star NABERS Energy for Hotels" and "J1V2-Green Star alternative compliance"
   - **Class_5**: Includes methods like "J1V1-minimum 5.5-star NABERS Energy base building" and "J1V2-Green Star alternative compliance"
   - **Class_6**: Includes methods like "J1V1-minimum 4.5-star NABERS Energy for Shopping Centres" and "J1V2-Green Star alternative compliance"
   - **Class_7-9c**: Primarily use the "J1V2-Green Star alternative compliance" method

4. **Integration with Report Service**:
   - The verification methods are accessed through the `getVerificationMethods` utility function
   - The report service includes these methods in the energy use section of the compliance report
   - The methods are displayed conditionally based on the building class

5. **Default Handling**:
   - If a specific verification method isn't found for a building class, the default method is used
   - The default method provides a standard verification approach

This modular approach allows for easy addition of new verification methods and ensures that each building class has appropriate compliance verification options.

### Bug Fixes
- Fixed the `createdBy` field in the Project schema by setting it to the same value as the `owner` field in the `createProject` function
- Improved error handling in the `getClimateZoneByLocation` function
- Updated validation messages to be more descriptive
- Fixed the import path for `locationToClimateZone.json` in `reportService.js`

## Notes
- The `Decision-Tree.json` file is the source of truth for building classifications, climate zones, and compliance pathways
- The `locationToClimateZone.json` file maps locations to climate zones and contains heating, cooling, and dehumidification data
- The `buildingTypeToClassification.json` file maps building types to NCC classifications
- The `createdBy` field in the Project schema is set to the same value as the `owner` field
- The J1P2 calculation files in the `backend/data/decision-trees` directory implement the formulas for heating, cooling, and thermal energy load calculations

## Today's Changes (2024-03-19)

### J1P2 Calculations for Class_2 and Class_4 Buildings
- Added J1P2 calculations to the Performance Requirement section of the report
- Created three JavaScript files in the `backend/data/decision-trees` directory:
  - `j1p2totalheatingload.js`: Implements the heating load calculation formula
  - `j1p2totalcoolingload.js`: Implements the cooling load calculation formula
  - `j1p2thermalenergyload.js`: Implements the thermal energy load calculation formula
- Updated the `generateJ1P2CalcInfo` method in `reportService.js` to use these files
- The calculations are only displayed for Class_2 and Class_4 buildings

### Climate Data for Class_2 and Class_4 Buildings
- Added heating, cooling, and dehumidification data to the Building Classification & Climate Zone section of the report
- This data is only displayed for Class_2 and Class_4 buildings
- The data is sourced from the `locationToClimateZone.json` file
- Updated the `generateClimateZoneInfo` method in `reportService.js` to include this data
- Updated the `ProjectReport.js` component to conditionally display this data

### Report Structure Reorganization
- Reorganized the report display into four main sections for better organization and readability
- Added clear section headers with consistent styling
- Maintained all existing functionality while improving the layout

### Building Classification Fixes
- Fixed the building classification display in the project details page
- Updated the `generateBuildingClassificationInfo` method in `reportService.js` to correctly return the classType
- Ensured that the building classification (e.g., "Class_6") is properly displayed in the report

### ReportService Implementation
The `ReportService` class is responsible for generating comprehensive compliance reports for projects. It works as follows:

1. **Initialization**: The service is initialized with a project object and an optional section parameter (defaults to 'full').

2. **Report Generation**: The `generateReport` method orchestrates the report generation process:
   - It starts with basic project information
   - Based on the requested section, it adds specific information:
     - Building classification and climate zone
     - Compliance pathway
     - Building fabric specifications
     - Special requirements
     - Exemptions
     - Section-specific information
     - J1P2 calculations (for Class_2 and Class_4 buildings)

3. **Section-Specific Methods**:
   - `generateProjectInfo`: Returns basic project details
   - `generateBuildingClassificationInfo`: Retrieves and formats building classification data
   - `generateClimateZoneInfo`: Gets climate zone information based on location and includes heating, cooling, and dehumidification data for Class_2 and Class_4 buildings
   - `generateCompliancePathwayInfo`: Determines the appropriate compliance pathway
   - `generateBuildingFabricInfo`: Formats building fabric specifications
   - `generateSpecialRequirementsInfo`: Retrieves special requirements for the building
   - `generateExemptionsInfo`: Checks for applicable exemptions
   - `generateSectionSpecificInfo`: Gets detailed information for a specific NCC section
   - `generateJ1P2CalcInfo`: Calculates J1P2 values (heating, cooling, and thermal energy load) for Class_2 and Class_4 buildings

4. **Data Sources**: The service uses utility functions from `decisionTreeUtils.js` to access data from:
   - `Decision-Tree.json`: Contains the decision tree structure
   - `buildingTypeToClassification.json`: Maps building types to NCC classifications
   - `locationToClimateZone.json`: Maps locations to climate zones and contains heating, cooling, and dehumidification data
   - J1P2 calculation files: Implement the formulas for heating, cooling, and thermal energy load calculations

5. **Error Handling**: Each method includes proper error handling to ensure the report generation process is robust.

The report is then displayed in the frontend using the `ProjectReport.js` component, which renders the data in a structured format with appropriate sections and styling. 

## Creating New Decision Trees

The application uses a modular decision tree structure to store and retrieve compliance-related data. This section explains how to create a new decision tree and integrate it into the system.

### Step 1: Create the Decision Tree JSON File

1. Create a new JSON file in the `backend/data/decision-trees` directory with a descriptive name (e.g., `verification-methods.json`).
2. Structure the file according to the following template:

```json
{
  "version": "1.0",
  "last_updated": "YYYY-MM-DD",
  "section_name": {
    "key1": {
      "property1": "value1",
      "property2": "value2"
    },
    "key2": {
      "property1": "value1",
      "property2": "value2"
    },
    "default": {
      "property1": "default_value1",
      "property2": "default_value2"
    }
  }
}
```

3. Replace `section_name` with the name of your decision tree (e.g., `verification_methods`).
4. Define the keys and properties according to your data structure.
5. Include a `default` key for cases where a specific key is not found.

### Step 2: Update the Decision Tree Configuration

1. Open `backend/data/decision-trees/decision-tree-config.js`.
2. Add your new decision tree name to the `sections` array:

```javascript
sections: [
  'exemptions',
  'building-classifications',
  'climate-zones',
  'compliance-pathways',
  'special-requirements',
  'building-fabric',
  'energy-use',
  'your-new-decision-tree'  // Add your new decision tree here
]
```

### Step 3: Create a Utility Function

1. Open `backend/utils/decisionTreeUtils.js`.
2. Create a new function to retrieve data from your decision tree:

```javascript
const getYourNewDecisionTree = async (key) => {
  try {
    // Get data from the modular structure
    const data = await getSection('your-new-decision-tree');
    if (!data || !data.section_name) {
      throw new Error('No data found');
    }

    // Get the data for the specific key
    const result = data.section_name[key];
    
    // If no specific data found for this key, use the default
    if (!result) {
      return data.section_name.default;
    }

    return result;
  } catch (error) {
    console.error(`Error getting data for ${key}:`, error);
    throw error;
  }
};
```

3. Export the new function by adding it to the `module.exports` object:

```javascript
module.exports = {
  // ... existing exports
  getYourNewDecisionTree,
};
```

### Step 4: Update the ReportService

1. Open `backend/services/reportService.js`.
2. Import your new utility function:

```javascript
const {
  // ... existing imports
  getYourNewDecisionTree
} = require('../utils/decisionTreeUtils');
```

3. Add a new property to the constructor:

```javascript
constructor(project, section = 'full') {
  // ... existing properties
  this.yourNewData = null;
}
```

4. Create a new method to generate information from your decision tree:

```javascript
async generateYourNewDataInfo() {
  try {
    // Get the key based on project data
    const key = this.project.someProperty;
    
    // Get the data from the decision tree
    this.yourNewData = await getYourNewDecisionTree(key);
    
    return {
      // Return the data in a structured format
      property1: this.yourNewData.property1,
      property2: this.yourNewData.property2
    };
  } catch (error) {
    return {
      error: `Error getting data: ${error.message}`
    };
  }
}
```

5. Update the `generateReport` method to include your new data:

```javascript
async generateReport() {
  try {
    // ... existing code

    if (this.section === 'full' || this.section === 'your-section') {
      report.yourNewData = await this.generateYourNewDataInfo();
    }

    // ... existing code
  } catch (error) {
    // ... error handling
  }
}
```

### Step 5: Update the Frontend Component

1. Open the relevant frontend component (e.g., `frontend/src/components/ProjectReport.js`).
2. Add a new section to display your data:

```jsx
{/* Your New Data Section */}
{report.yourNewData && (
  <Box sx={{ mb: 4 }}>
    <Typography variant="h5" gutterBottom>
      Your New Data Section
    </Typography>
    <Grid container spacing={2}>
      <Grid item xs={12}>
        <Typography variant="subtitle1">Property 1</Typography>
        <Typography variant="body1">
          {report.yourNewData.property1}
        </Typography>
      </Grid>
      <Grid item xs={12}>
        <Typography variant="subtitle1">Property 2</Typography>
        <Typography variant="body2" color="text.secondary">
          {report.yourNewData.property2}
        </Typography>
      </Grid>
    </Grid>
  </Box>
)}
```

### Example: Adding Verification Methods

As an example, to add verification methods to the energy use section:

1. Create `verification-methods.json` with verification methods for each building classification.
2. Add 'verification-methods' to the sections array in `decision-tree-config.js`.
3. Create `getVerificationMethods` function in `decisionTreeUtils.js`.
4. Update `generateEnergyUseInfo` in `reportService.js` to include verification methods.
5. Update the energy use section in `ProjectReport.js` to display verification methods.

This modular approach allows for easy addition of new decision trees and integration with the existing report generation system. 

### Example: Adding Climate Data for Specific Building Classes

As an example of how we added heating, cooling, and dehumidification data for Class_2 and Class_4 buildings:

1. Updated the `locationToClimateZone.json` file to include heating, cooling, and dehumidification data for each location.
2. Updated the `generateClimateZoneInfo` method in `reportService.js` to include this data for Class_2 and Class_4 buildings.
3. Updated the `ProjectReport.js` component to conditionally display this data based on the building class.

This approach allows for easy addition of new data to the report based on specific building classifications. 

### Example: Adding J1P2 Calculations

As an example of how we added J1P2 calculations for Class_2 and Class_4 buildings:

1. Created three JavaScript files in the `backend/data/decision-trees` directory:
   - `j1p2totalheatingload.js`: Implements the heating load calculation formula
   - `j1p2totalcoolingload.js`: Implements the cooling load calculation formula
   - `j1p2thermalenergyload.js`: Implements the thermal energy load calculation formula
2. Updated the `generateJ1P2CalcInfo` method in `reportService.js` to use these files
3. The calculations are only displayed for Class_2 and Class_4 buildings
4. The data is sourced from the `locationToClimateZone.json` file

This approach allows for easy addition of new calculations to the report based on specific building classifications. 

## Report Structure (Updated View)

The report structure is now more flexible. While the frontend might still group sections visually, the backend generates:

1. **Core Sections**: Directly added to the report object (e.g., `projectInfo`, `buildingClassification`, `climateZone`, `j1p2calc`).

2. **Dynamic Sections**: An array `dynamicSections` containing objects for each applicable, standardized JSON section, sorted by `displayOrder`. The frontend iterates through this array to render sections like:
   - J1P1 Energy Use
   - J1P3 Energy Usage
   - J1P4 EVSE
   - J2 Energy Efficiency
   - J3D3 Requirements (if converted)
   - J3D4 Ceiling Fans
   - Verification Methods
   - Energy Monitor
   - Exemptions
   - Special Requirements

Each dynamic section follows a standardized JSON format:
```json
{
  "sectionId": "unique_section_id",
  "title": "Section Title",
  "displayOrder": 1,
  "overallApplicability": {
    "buildingClasses": ["Class_2", "Class_4"],
    "climateZones": ["Zone1", "Zone2"],
    "minFloorArea": 100,
    "maxFloorArea": 1000
  },
  "contentBlocks": [
    {
      "blockTitle": "Block Title",
      "contentType": "text|table|list",
      "content": "...",
      "blockApplicability": {
        // Similar to overallApplicability
      }
    }
  ]
}
```

The frontend uses the `DynamicSectionRenderer` component to handle different content types and render them appropriately.

## Lighting & Power Report Implementation

### Backend Structure
The lighting and power report is implemented through two main components:

1. **EnergyMonitorReportService** (`backend/services/energy_monitor_reportService.js`):
   - Handles report generation for lighting and power compliance
   - Structure:
     ```javascript
     {
       projectInfo: {
         name: string,
         buildingType: string,
         location: string,
         floorArea: number,
         totalAreaOfHabitableRooms: number
       },
       buildingClassification: {
         buildingType: string,
         classType: string,
         name: string,
         description: string,
         typicalUse: string,
         commonFeatures: string[],
         notes: string,
         technicalDetails: object
       },
       climateZone: {
         zone: number,
         name: string,
         description: string,
         annualHeatingDegreeHours: number,
         annualCoolingDegreeHours: number,
         annualDehumidificationGramHours: number
       },
       EnergyMonitorReport: {
         sections: Array<{
           sectionId: string,
           title: string,
           displayOrder: number,
           contentBlocks: Array<{
             blockId: string,
             contentType: string,
             content: string | object
           }>
         }>
       }
     }
     ```

2. **JSON Data Structure** (`backend/data/j9monitor/`):
   - All lighting and power related JSON files should be placed in this directory
   - Each JSON file must include:
     ```json
     {
       "category": "j9monitor",
       "sectionId": "unique_section_id",
       "title": "Section Title",
       "displayOrder": number,
       "overallApplicability": {
         "buildingClasses": ["Class_2", "Class_4"],
         "climateZones": [1, 2, 3],
         "minFloorArea": number,
         "maxFloorArea": number
       },
       "contentBlocks": [
         {
           "blockId": "unique_block_id",
           "contentType": "text|table|list",
           "content": "content or data",
           "blockApplicability": {
             "buildingClasses": ["Class_2", "Class_4"],
             "climateZones": [1, 2, 3]
           }
         }
       ]
     }
     ```

### Frontend Implementation
The lighting and power report is displayed using the `EnergyMonitorReport` component (`frontend/src/components/EnergyMonitorReport.js`):

1. **Component Structure**:
   ```jsx
   <Container>
     <Paper>
       <Typography>Lighting & Power Compliance Report</Typography>
       <Box>
         {/* Project Information */}
         <Box>
           <Typography>Project Information</Typography>
           <Grid>
             {/* Project details */}
           </Grid>
         </Box>

         {/* Building Classification & Climate Zone */}
         <Box>
           <Typography>Building Classification & Climate Zone</Typography>
           <Grid>
             {/* Classification and climate details */}
           </Grid>
         </Box>

         {/* Dynamic Sections */}
         <Box>
           <Typography>Report Sections</Typography>
           {/* Render dynamic sections */}
         </Box>
       </Box>
     </Paper>
   </Container>
   ```

2. **Redux Integration**:
   - Uses `energy_monitor_reportSlice.js` for state management
   - Handles loading, error states, and report data
   - Provides `generateEnergyMonitorReport` action for report generation

### Important Notes

1. **JSON File Location**:
   - All lighting and power related JSON files must be in `backend/data/j9monitor/`
   - Each file must have the `category: "j9monitor"` field
   - File naming should be descriptive and follow a consistent pattern

2. **Section Loading**:
   - The `sectionLoader.js` utility loads all JSON files from the j9monitor directory
   - Files are filtered based on the `category` field
   - Sections are processed based on their applicability rules

3. **Applicability Rules**:
   - Each section and content block can have applicability rules
   - Rules are checked against project data (building class, climate zone, etc.)
   - Only applicable sections and blocks are included in the report

4. **Content Types**:
   - Text content: Simple text display
   - Table content: Structured data in tabular format
   - List content: Ordered or unordered lists

5. **Error Handling**:
   - The service includes comprehensive error handling
   - Missing or invalid JSON files are logged
   - Invalid sections or blocks are skipped with warnings

6. **Performance Considerations**:
   - JSON files are loaded and cached on service initialization
   - Applicability checks are performed efficiently
   - Dynamic sections are generated only when needed

7. **Maintenance**:
   - New sections can be added by creating new JSON files
   - Existing sections can be modified by updating JSON files
   - The structure allows for easy addition of new content types

## Creating a New Section (e.g., J7 Lighting)

To create a new section in the NCC Section Compliance Checker, follow these steps:

### 1. Backend Setup
Server.js
sectionLoader.js
app.js deleted merge with server.js

#Frontend
ProjectDetails.js


#### Required Files:

1. **Service File** (`backend/services/[sectionName]_reportService.js`):
   ```javascript
   class [SectionName]ReportService {
     constructor(project, section = 'full') {
       this.project = project;
       this.sectionParam = section;
       this.buildingClassification = null;
       this.climateZone = null;
     }

     async initialize() {
       // Load building classification and climate zone
     }

     async generateReport() {
       // Generate report with project info, building classification, climate zone
       // and dynamic sections
     }
   }
   ```

2. **Controller File** (`backend/controllers/[sectionName]_reportController.js`):
   ```javascript
   const generate[SectionName]Report = asyncHandler(async (req, res) => {
     // Handle report generation with proper error handling
     // and authorization checks
   });
   ```

3. **Routes File** (`backend/routes/[sectionName]_reportRoutes.js`):
   ```javascript
   router.get('/:id/report', protect, generate[SectionName]Report);
   ```

4. **JSON Data Files** (`backend/data/[sectionName]/`):
   - Create a directory for your section's JSON files
   - Each JSON file should follow the standard format:
   ```json
   {
     "category": "[sectionName]",
     "sectionId": "unique_section_id",
     "title": "Section Title",
     "displayOrder": number,
     "overallApplicability": {
       "buildingClasses": ["Class_2", "Class_4"],
       "climateZones": [1, 2, 3],
       "minFloorArea": number,
       "maxFloorArea": number
     },
     "contentBlocks": [
       {
         "blockId": "unique_block_id",
         "contentType": "text|table|list",
         "content": "content or data",
         "blockApplicability": {
           "buildingClasses": ["Class_2", "Class_4"],
           "climateZones": [1, 2, 3]
         }
       }
     ]
   }
   ```

### 2. Frontend Setup

#### Required Files:

1. **Report Component** (`frontend/src/components/reports/[SectionName]Report.js`):
   ```javascript
   const [SectionName]Report = () => {
     // Use Redux hooks for state management
     // Fetch report data
     // Render report with DynamicSectionRenderer
   };
   ```

2. **Redux Slice** (`frontend/src/store/slices/[sectionName]_reportSlice.js`):
   ```javascript
   const [sectionName]Slice = createSlice({
     name: '[SectionName]',
     initialState: {
       report: null,
       loading: false,
       error: null,
     },
     // Add reducers and async thunks
   });
   ```

3. **Update Store** (`frontend/src/store/index.js`):
   ```javascript
   import [sectionName]Reducer from './slices/[sectionName]_reportSlice';

   const store = configureStore({
     reducer: {
       // ... other reducers
       [SectionName]: [sectionName]Reducer,
     },
   });
   ```

### 3. Integration Steps

1. **Backend Integration**:
   - Add the new route to `server.js`
   - Register the new service in the dependency injection container
   - Add Swagger documentation for the new endpoints

2. **Frontend Integration**:
   - Add the new route to `app.js deleted merge with server.js`
   - Add a button/link to access the new section in `ProjectDetails.js`
   - Update navigation components if needed

3. **Data Integration**:
   - Create JSON files for each subsection
   - Ensure proper categorization and applicability rules
   - Test with different building types and climate zones

### 4. Testing

1. **Backend Testing**:
   - Test report generation with different project types
   - Verify error handling and authorization
   - Check dynamic section generation

2. **Frontend Testing**:
   - Test report rendering
   - Verify Redux state management
   - Check loading and error states
   - Test print functionality

### 5. Common Components Used

1. **DynamicSectionRenderer**:
   - Used for rendering dynamic content blocks
   - Handles different content types (text, table, list)
   - Manages section applicability

2. **Project Information Display**:
   - Shows project details
   - Displays building classification
   - Shows climate zone information

3. **Print Functionality**:
   - Implemented using window.print()
   - Includes print-specific styling

### 6. Best Practices

1. **Code Organization**:
   - Follow the established pattern for file naming and structure
   - Use consistent error handling
   - Implement proper authorization checks

2. **Data Management**:
   - Use Redux for state management
   - Implement proper loading and error states
   - Cache data when appropriate

3. **User Experience**:
   - Provide clear loading indicators
   - Show meaningful error messages
   - Include print functionality
   - Maintain consistent styling

4. **Performance**:
   - Optimize JSON file loading
   - Implement proper caching
   - Use efficient rendering techniques

### Content Types That Can Be Rendered**:
   - `text`: Simple text display
   - `table`: Structured data in tabular format
   - `list`: Ordered or unordered lists
   - `button`: Interactive button elements with the following properties:
     ```json
     {
       "contentType": "button",
       "buttonType": "primary|secondary|outlined|text",
       "label": "Button Text",
       "action": "action_type",
       "actionParams": {
         "param1": "value1",
         "param2": "value2"
       },
       "disabled": boolean,
       "icon": "icon_name",
       "tooltip": "Button tooltip text"
     }
     ```
     Supported button types:
     - `primary`: Main action buttons
     - `secondary`: Alternative action buttons
     - `outlined`: Less prominent actions
     - `text`: Text-only buttons
     
     Common actions:
     - `navigate`: Navigate to another section/page
     - `print`: Print the current report
     - `download`: Download report as PDF
     - `calculate`: Perform calculations
     - `validate`: Validate form or data
     - `custom`: Custom action defined in the frontend

## If We Want to Add a New Content Type

To add a new content type that can be rendered in the frontend, follow these steps:

1. **Update Frontend Component**:
   - Modify `DynamicSectionRenderer` component to handle the new content type
   - Create a new renderer component for the specific content type
   - Add the new content type to the switch statement in `DynamicSectionRenderer`

2. **Backend Structure**:
   Add the new content type to the JSON structure in backend data files:
   ```json
   {
     "contentBlocks": [
       {
         "blockId": "unique_block_id",
         "contentType": "newType",  // new content type
         "content": {
           // content specific properties
         },
         "blockApplicability": {
           "buildingClasses": ["Class_2", "Class_4"],
           "climateZones": [1, 2, 3]
         }
       }
     ]
   }
   ```

3. **Update Documentation**:
   Add the new content type to the "Content Types That Can Be Rendered" section in this file:
   ```markdown
   ### Content Types That Can Be Rendered**:
      - `text`: Simple text display
      - `table`: Structured data in tabular format
      - `list`: Ordered or unordered lists
      - `button`: Interactive button elements
      - `newType`: Description of new content type with example structure
   ```

4. **Update sectionLoader.js**:
   - Add validation for the new content type
   - Update the list of valid content types
   - Add specific validation rules for the new content type

5. **Testing**:
   - Create test cases for the new content type
   - Test rendering in different scenarios
   - Test validation in sectionLoader
   - Test integration with existing components

6. **Example Implementation**:
   ```jsx
   // components/NewTypeRenderer.js
   const NewTypeRenderer = ({ content }) => {
     // Render logic for new content type
     return (
       <div className="new-type-container">
         {/* Render content */}
       </div>
     );
   };

   // Update DynamicSectionRenderer
   const DynamicSectionRenderer = ({ contentBlock }) => {
     const { contentType, content } = contentBlock;

     switch (contentType) {
       case 'text':
         return <TextRenderer content={content} />;
       case 'table':
         return <TableRenderer content={content} />;
       case 'list':
         return <ListRenderer content={content} />;
       case 'button':
         return <ButtonRenderer content={content} />;
       case 'newType':  // new content type
         return <NewTypeRenderer content={content} />;
       default:
         return <TextRenderer content="Unsupported content type" />;
     }
   };
   ```

7. **Validation in sectionLoader.js**:
   ```javascript
   const validateContentBlock = (block) => {
     const validContentTypes = ['text', 'table', 'list', 'button', 'newType'];
     
     if (!validContentTypes.includes(block.contentType)) {
       throw new Error(`Invalid content type: ${block.contentType}`);
     }
     
     // Additional validation for specific content types
     if (block.contentType === 'newType') {
       validateNewTypeContent(block.content);
     }
   };
   ```

This process ensures that:
- The new content type is properly documented
- The frontend can render it correctly
- The backend can validate it
- It integrates well with existing components
- It follows the application's architecture and patterns
###################################################
create new section 
Backend:

Service Layer:

Create a new service file: backend/services/jxxx_reportService.js

Use generateReport() method.

Use DynamicSectionsGenerator to generate the dynamic sections. Pass 'jxxx' as the section type.

Optional: Create specialized methods like generateAirConditioningInfo(), generateVentilationInfo(), etc.

Implement shouldIncludeSection() method.

Controller Layer:

Create a new controller file: backend/controllers/jxxx_reportController.js

Use express-async-handler for asynchronous operations.

Create a generateJXXXReport function. This function should:

Retrieve the project from the database.

Authorize user access to the project.

Instantiate the JXXXReportService.

Call the service's generateReport() method.

Send the generated report as a JSON response.

Route Layer:

Create a new route file: backend/routes/jxxx_reportRoutes.js

Use express.Router().

Use authMiddleware.protect to secure routes.

Define a GET route (/:id/report) to call the controller function.

Configuration:

Create a new configuration file: backend/data/jxxx/decision-tree-config.js

Define:

basePath: Base directory for the JXXX JSON data files (e.g., 'data/jxxx').

fileExtension: File extension for the JSON files ('.json').

sections: List of sections. (Can be empty initially).

Integration:

In backend/app.js deleted merge with server.js, import and use the new route:

const jxxxRoutes = require('./routes/jxxx_reportRoutes');
app.use('/api/jxxx', jxxxRoutes);

Data:

Ensure the JSON data files for JXXX are located in the backend/data/jxxx/ directory.

Front End:

Component:

Create a new component: frontend/src/components/JXXXReport.js

This component will:

Fetch the report data from the backend API (/api/jxxx/:projectId/report).

Display the report data. Use DynamicSectionRenderer.js to render the dynamic sections of the report.

Handle loading and error states.

Structure the report layout, including headings, sections, and data presentation.

Store (Redux Slice):

Create a new Redux slice: frontend/src/store/slices/jxxx_reportSlice.js

This slice will manage the state for the JXXX report data.

Define actions for:

Fetching the report data (e.g., fetchJXXXReport).

Setting the report data in the store.

Handling loading and error states.

Route:

Add a new route in frontend/src/app.js deleted merge with server.js to display the JXXXReport component. Make sure to protect this route.
<PrivateRoute path="/project/:projectId/jxxx-report" component={JXXXReport} />

Navigation:

Add a link or button in the appropriate location (e.g., in the project details page) to navigate to the JXXX report page. The link should use the project ID in the URL.

Here's a more detailed explanation:

Link/Button: You can use a standard HTML <a> tag for a link, or a <button> element (styled as a button) if you want more control over the appearance and behavior.

URL: The key is to construct the URL correctly.  It should follow the pattern /project/:projectId/jxxx-report, where :projectId is a placeholder for the actual ID of the project.  This ID is essential for the backend to retrieve the correct data for the report.

##############################
Create a new service file: backend/services/j6hvav_reportService.js
Use generateReport() method.
Use DynamicSectionsGenerator to generate the dynamic sections. Pass 'j6hvac' as the section type.
Implement shouldIncludeSection() method.
use j7lighting_reportService.js and exactly use same methode strcture and concept, do not create other files yet

Create a new controller file: backend/controllers/j6hvac_reportController.js
Use express-async-handler for asynchronous operations.
Create a generateJ6hvacReport function. This function should:
Retrieve the project from the database.
Authorize user access to the project.
Instantiate the J6hvacReportService.
Call the service's generateReport() method.
Send the generated report as a JSON response.
use j7lighting_reportController.js and exactly use same methode strcture and concept, do not create other files yet

Create a new route file: backend/routes/j6hvac_reportRoutes.js
Use express.Router().
Use authMiddleware.protect to secure routes.
Define a GET route (/:id/report) to call the controller function.
use j7lighting_reportRoutes.js and exactly use same methode strcture and concept, do not create other files yet


// Configuration: -- May Not Required
Create a new configuration file: backend/data/j6hvac/decision-tree-config.js
Define:
basePath: Base directory for the j6dX JSON data files (e.g., 'data/j6hvac').
fileExtension: File extension for the JSON files ('.json').
sections: List of sections. (Can be empty initially).
use decision-tree-config.js in j7lighting folder and exactly use same methode strcture and concept, do not create other files yet

In backend/app.js deleted merge with server.js, import and use the new route:
const j6hvavRoutes = require('./routes/j6hvac_reportRoutes');
app.use('/api/j6hvac', j6hvacRoutes);
use j7lighting as main sample and use exactly same structure 

In backend/server.js, import and mounted routes j6hvac_reportRoutes
use j7lighting as main sample and use exactly same structure 

Add 'j6hvac' to the sectionCache object in sectionLoader.js

Create a new component: frontend/src/components/reports/J6hvacReport.js
This component will:
Fetch the report data from the backend API (/api/j6hvac/:projectId/report).
Display the report data. Use DynamicSectionRenderer.js to render the dynamic sections of the report.
Handle loading and error states.
Structure the report layout, including headings, sections, and data presentation.
use j7lighting as main sample and use exactly same structure 
J7LightingReport.js as main sample and use exactly same methodes and structure

Store (Redux Slice):
Create a new Redux slice: frontend/src/store/slices/j6hvac_reportSlice.js
This slice will manage the state for the J6hvac report data.
Define actions for:
Fetching the report data (e.g., fetchJ6hvacReport).
Setting the report data in the store.
Handling loading and error states.
use j7lighting as main sample and use exactly same structure 
j7lighting_reportSlice.js as main sample and use exactly same methodes and structure

Route:
Add a new route in frontend/src/app.js deleted merge with server.js to display the J6hvacReport component. Make sure to protect this route.
<PrivateRoute path="/project/:projectId/j6hvac-report" component={J6hvacReport} />
use j7lighting as main sample and use exactly same structure 

Redux Store Registration:
In frontend/src/store/index.js, register the J6hvac reducer 

Navigation:
Add a link or button in the appropriate location (e.g., in the project details page) to navigate to the J6hvac report page. The link should use the project ID in the URL.
It should follow the pattern /project/:projectId/j6hvac-report, where :projectId is a placeholder for the actual ID of the project.  This ID is essential for the backend to retrieve the correct data for the report.
Call it J6 HVAC and put it before j7xxx use same methode, as j7xxx 


+++++++++++++++++++++++++++++++++++++++++++++
accepted contentType

paragraph - For text paragraphs
heading - For headings (h3-h6)
list - For lists (which we're already using)
paragraphList - For multiple paragraphs
keyValue - For key-value pairs
table - For tables
button - For buttons
note - For notes

"add,authority-meter,4,-8": Invalid node type: authority-meter. Available types: smart-meter, smartmeter, meter, transformer, load, cloud, wireless, rs485, ethernet, onpremise, onpremise, auth-meter, authmeter, meter-memory, metermemory